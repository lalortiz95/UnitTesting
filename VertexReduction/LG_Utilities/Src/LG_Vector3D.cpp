#include "LG_Vector3D.h"

namespace LevelGenerator
{
	/************************************************************************************************************************/
	/* Implementación de funciones del vector                               												*/
	/************************************************************************************************************************/
	LG_Vector3D::LG_Vector3D()
	{

	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D::LG_Vector3D(float InX, float InY, float InZ) : X(InX), Y(InY), Z(InZ)
	{

	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D::~LG_Vector3D()
	{

	}

	/************************************************************************************************************************/
	/* Implementación de operadores aritméticos                             												*/
	/************************************************************************************************************************/

	LG_Vector3D LG_Vector3D::operator+(const LG_Vector3D& V) const
	{
		return LG_Vector3D(X + V.X, Y + V.Y, Z + V.Z);
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator-(const LG_Vector3D& V) const
	{
		return LG_Vector3D(X - V.X, Y - V.Y, Z - V.Z);
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator*(float Scale) const
	{
		return LG_Vector3D(X * Scale, Y * Scale, Z * Scale);
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator*(const LG_Vector3D& V) const
	{
		return LG_Vector3D(X * V.X, Y * V.Y, Z * V.Z);
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator/(float Scale) const
	{
		const float RScale = 1.f / Scale;
		return LG_Vector3D(X * RScale, Y * RScale, Z * RScale);
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator/(const LG_Vector3D& V) const
	{
		return LG_Vector3D(X / V.X, Y / V.Y, Z / V.Z);
	}



	/************************************************************************************************************************/
	/* Implementación de operadores lógicos                                 												*/
	/************************************************************************************************************************/
	bool LG_Vector3D::operator==(const LG_Vector3D& V) const
	{
		return X == V.X && Y == V.Y && Z == V.Z;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	bool LG_Vector3D::operator!=(const LG_Vector3D& V) const
	{
		return X != V.X || Y != V.Y || Z != V.Z;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	bool LG_Vector3D::operator<(const LG_Vector3D& Other) const
	{
		return X < Other.X && Y < Other.Y && Z < Other.Z;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	bool LG_Vector3D::operator>(const LG_Vector3D& Other) const
	{
		return X > Other.X && Y > Other.Y && Z > Other.Z;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	bool LG_Vector3D::operator<=(const LG_Vector3D& Other) const
	{
		return X <= Other.X && Y <= Other.Y && Z <= Other.Z;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	bool LG_Vector3D::operator>=(const LG_Vector3D& Other) const
	{
		return X >= Other.X && Y >= Other.Y && Z >= Other.Z;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	bool LG_Vector3D::Equals(const LG_Vector3D& V, float Tolerance) const
	{
		return abs(X - V.X) < Tolerance &&abs(Y - V.Y) < Tolerance && abs(Z - V.Z) < Tolerance;
	}

	/************************************************************************************************************************/
	/* Implementación de operadores de asignación compuesta                 												*/
	/************************************************************************************************************************/
	LG_Vector3D LG_Vector3D::operator+=(const LG_Vector3D& V)
	{
		X += V.X; Y += V.Y; Z += V.Z;
		return *this;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator-=(const LG_Vector3D& V)
	{
		X -= V.X; Y -= V.Y; Z -= V.Z;
		return *this;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator*=(float Scale)
	{
		X *= Scale; Y *= Scale; Z *= Scale;
		return *this;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator/=(float V)
	{
		const float RV = 1.f / V;
		X *= RV; Y *= RV; Z *= RV;
		return *this;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator*=(const LG_Vector3D& V)
	{
		X *= V.X; Y *= V.Y; Z *= V.Z;
		return *this;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::operator/=(const LG_Vector3D& V)
	{
		X /= V.X; Y /= V.Y; Z /= V.Z;
		return *this;
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	float LG_Vector3D::Magnitud(const LG_Vector3D & V)
	{
		return sqrt(pow(V.X, 2) + pow(V.Y, 2) + pow(V.Z, 2));
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	LG_Vector3D LG_Vector3D::Normalize(const LG_Vector3D & V)
	{
		return V / Magnitud(V);
	}

	/************************************************************************/
	/* Producto Punto                                                       */
	/************************************************************************/
	float LG_Vector3D::operator|(const LG_Vector3D& V) const
	{
		return X*V.X + Y*V.Y + Z*V.Z;
	}

	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	float LG_Vector3D::operator^(const LG_Vector3D& V) const
	{
		return ((Y*V.Z - Z*V.Y) - (X * V.Z - Z*V.X) + (X * V.Y - Y * V.X));
	}
	/************************************************************************/
	/*                                                                      */
	/************************************************************************/
	float LG_Vector3D::DotProduct(const LG_Vector3D& A, const LG_Vector3D& B)
	{
		return A | B;
	}

	LG_Vector3D LG_Vector3D::Cross3(const LG_Vector3D & V, const LG_Vector3D & B)
	{
		return LG_Vector3D((V.Y*B.Z - V.Z*B.Y), (-1 * (V.X * B.Z - V.Z*B.X)), (V.X * B.Y - V.Y * B.X));
	}
}